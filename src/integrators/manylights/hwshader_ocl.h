#ifndef hwshader_OCL
#define hwshader_OCL
const char *hwshader_ocl =
"struct PixelElement{\n"
"    float3 diff_col;\n"
"    float3 spec_col;\n"
"    float3 p;\n"
"    float3 n;\n"
"    float roughness;\n"
"    float3 eta;\n"
"    float3 k;\n"
"    float3 wi;\n"
"};\n"
"\n"
"struct LightElement{\n"
"    float3 col;\n"
"    float3 n;\n"
"    float3 p;\n"
"    float rad;\n"
"    float coeff;\n"
"    int type;\n"
"};\n"
"\n"
"struct OutputElement{\n"
"    float3 col;\n"
"};\n"
"\n"
"#define PI 3.1415926\n"
"\n"
"float3 lambertian(float3 albedo, float3 p, float3 n, float3 lp, float3 lcol, float3 ln){\n"
"    float3 dir = lp - p;\n"
"    float3 wi = normalize(dir);\n"
"    float wi_dot_n = fmax(0.0f, dot(wi, n));\n"
"    \n"
"    float3 col = albedo * (float3)(wi_dot_n) * lcol / (float3)(PI);\n"
"\n"
"    return col;\n"
"}\n"
"\n"
"float ggx_dist(float3 h, float3 n, float alpha){\n"
"    float noh = clamp(dot(h, n), 0.0f, 1.0f);\n"
"    float alpha2 = alpha * alpha;\n"
"\n"
"    float denom = (noh * noh) * (alpha2 - 1.0f) + 1.0f;\n"
"\n"
"    return alpha2 / (denom * denom * PI);\n"
"}\n"
"\n"
"float schlick_geom(float alpha, float3 n, float3 v, float3 l){\n"
"    float k = alpha + 1.0f;\n"
"    k = (k * k) / 8.0f;\n"
"    \n"
"    float nov = clamp(dot(n, v), 0.0f, 1.0f);\n"
"    float nol = clamp(dot(n, l), 0.0f, 1.0f);\n"
"\n"
"    float g1 = nov / (nov * (1.0f - k) + k);\n"
"    float g2 = nol / (nol * (1.0f - k) + k);\n"
"\n"
"    return g1 * g2;\n"
"}\n"
"\n"
"float3 schlick_fres(float3 v, float3 h, float3 f0){\n"
"    float voh = 1.0 - clamp(dot(v, h), 0.0f, 1.0f);\n"
"    voh = powr(voh, 5.0f);\n"
"    return f0 + ((float3)(1.0f) - f0) * (float3)(voh);\n"
"}\n"
"\n"
"float3 cookTorrance(struct PixelElement pixel, struct LightElement light){\n"
"    float3 l = normalize(light.p - pixel.p);\n"
"    float3 h = normalize(pixel.wi + l);\n"
"    float3 n = normalize(pixel.n);\n"
"    \n"
"    float d = ggx_dist(h, n, pixel.roughness);\n"
"    float g = schlick_geom(pixel.roughness, n, pixel.wi, l);\n"
"    float3 f = schlick_fres(pixel.wi, h, pixel.spec_col);\n"
"\n"
"    float nol = clamp(dot(n, l), 0.f, 1.f);\n"
"    float nov = clamp(dot(pixel.wi, n), 0.f, 1.f);\n"
"\n"
"    return f * d * g / clamp(4.0f * (nol * nov + 0.05f), 0.f, 1.f);\n"
"}\n"
"\n"
"__kernel void shade(__global const struct PixelElement* pixels, __global const struct LightElement* lights, \n"
"    __global struct OutputElement *output, int num_pixels, float min_dist){\n"
"    int i = get_global_id(0);\n"
"    if(i >= num_pixels){\n"
"        return;\n"
"    }\n"
"\n"
"    float coeff = (lights[i].coeff + 1.0f) / 2.0f;\n"
"\n"
"    float3 diffuse = lambertian(pixels[i].diff_col, pixels[i].p, pixels[i].n, lights[i].p, lights[i].col, \n"
"        lights[i].n);\n"
"\n"
"    float3 specular = pixels[i].roughness < 1.0001f ? cookTorrance(pixels[i], lights[i]) : (float3)(0.0f);\n"
"\n"
"    float3 color = diffuse + specular;\n"
"\n"
"    float3 light_col = lights[i].col;\n"
"\n"
"    float3 dir = pixels[i].p - lights[i].p;\n"
"    if(lights[i].type != 0){\n"
"        float dist = fmax(min_dist, length(dir));\n"
"        light_col /= (dist * dist);\n"
"    }\n"
"\n"
"    if(lights[i].type == 2){\n"
"        float lnodir = fmax(0.0f, dot(normalize(dir), lights[i].n));\n"
"        light_col *= (float3)(lnodir) / (float3)(PI);\n"
"    }\n"
"    \n"
"    color *= light_col;\n"
"\n"
"    //output[i].col = output[i].col + color * (float3)(coeff);\n"
"\n"
"    output[i].col = output[i].col + color * (float3)(coeff);\n"
"}\n";
#endif
