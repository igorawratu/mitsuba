#ifndef hwshader_OCL
#define hwshader_OCL
const char *hwshader_ocl =
"struct PixelElement{\n"
"    float3 diff_col;\n"
"    float3 spec_col;\n"
"    float3 p;\n"
"    float3 n;\n"
"    float roughness;\n"
"    float3 eta;\n"
"    float3 k;\n"
"    float3 wo;\n"
"};\n"
"\n"
"struct LightElement{\n"
"    float3 power;\n"
"    float3 diff_col;\n"
"    float3 spec_col;\n"
"    float3 p;\n"
"    float3 n;\n"
"    float roughness;\n"
"    float3 eta;\n"
"    float3 k;\n"
"    float3 wi;\n"
"    float coeff;\n"
"    float rad;\n"
"    int type;\n"
"};\n"
"\n"
"struct OutputElement{\n"
"    float3 col;\n"
"};\n"
"\n"
"#define PI 3.1415926\n"
"\n"
"float3 lambertian(float3 albedo, float3 p, float3 n, float3 lp){\n"
"    float3 dir = lp - p;\n"
"    float3 wi = normalize(dir);\n"
"    float wi_dot_n = fmax(0.0f, dot(wi, n));\n"
"    \n"
"    float3 col = albedo * (float3)(wi_dot_n) / (float3)(PI);\n"
"\n"
"    return col;\n"
"}\n"
"\n"
"float d_ggx(float3 h, float3 n, float alpha){\n"
"    float alpha2 = alpha * alpha;\n"
"    float noh = clamp(dot(n, h), 0.0f, 1.0f);\n"
"    float noh2 = noh * noh;\n"
"    float denom = noh2 * alpha2 + (1.0f - noh2);\n"
"\n"
"    return alpha2 / max(0.00001f, (float)(PI * denom * denom));\n"
"}\n"
"\n"
"float g_ggx_smith(float alpha, float3 n, float3 v, float3 l){\n"
"    float alpha2 = alpha * alpha;\n"
"    float nov = clamp(dot(n, v), 0.00001f, 1.0f);\n"
"    float nol = clamp(dot(n, l), 0.00001f, 1.0f);\n"
"    float tanv = (1.0f - nov) / nov;\n"
"    float tanl = (1.0f - nol) / nol;\n"
"\n"
"    float gv = 2.0f / (1.0f + sqrt(1.0f + alpha2 * tanv * tanv));\n"
"    float gl = 2.0f / (1.0f + sqrt(1.0f + alpha2 * tanl * tanl));\n"
"\n"
"    return gv * gl;\n"
"}\n"
"\n"
"float3 fresnel(float3 v, float3 h, float3 eta, float3 k) {\n"
"    float costheta = clamp(dot(v, h), 0.0f, 1.0f);\n"
"    float cos2theta = costheta * costheta;\n"
"    float sin2theta = 1.0f - cos2theta;\n"
"    float sin4theta = sin2theta * sin2theta;\n"
"\n"
"    float3 temp1 =  eta * eta - k * k - (float3)(sin2theta);\n"
"    float3 a2pb2 = sqrt(temp1 * temp1 + k * k * eta * eta * 4.0f);\n"
"    float3 a = sqrt((a2pb2 + temp1) * 0.5f);\n"
"\n"
"    float3 term1 = a2pb2 + (float3)(cos2theta);\n"
"    float3 term2 = a * (2.0f * costheta);\n"
"\n"
"    float3 rs2 = (term1 - term2) / (term1 + term2);\n"
"\n"
"    float3 term3 = a2pb2 * cos2theta + (float3)(sin4theta);\n"
"    float3 term4 = term2 * sin2theta;\n"
"\n"
"    float3 rp2 = rs2 * (term3 - term4) / (term3 + term4);\n"
"\n"
"    return 0.5f * (rp2 + rs2);\n"
"}\n"
"\n"
"float3 cookTorrance(struct PixelElement pixel, struct LightElement light){\n"
"    float3 l = normalize(light.p - pixel.p);\n"
"    float3 h = normalize(pixel.wo + l);\n"
"    float3 n = normalize(pixel.n);\n"
"    \n"
"    float d = d_ggx(h, n, pixel.roughness);\n"
"    float g = g_ggx_smith(pixel.roughness, n, pixel.wo, l);\n"
"    float3 f = fresnel(pixel.wo, h, pixel.eta, pixel.k) * pixel.spec_col;\n"
"\n"
"    float nol = clamp(dot(n, l), 0.f, 1.f);\n"
"    float nov = clamp(dot(pixel.wo, n), 0.f, 1.f);\n"
"\n"
"    return f * d * g / clamp(4.0f * (nol * nov + 0.05f), 0.f, 1.f);\n"
"}\n"
"\n"
"float3 getLightCol(struct LightElement light, struct PixelElement pixel){\n"
"    if(light.type != 2){\n"
"        return light.power;\n"
"    }\n"
"\n"
"    float3 dir = normalize(pixel.p - light.p);\n"
"    \n"
"    float nodir = clamp(dot(light.n, dir), 0.0f, 1.0f);\n"
"    float3 diffuse_col = light.power * nodir / (float)(PI);\n"
"\n"
"    float3 h = normalize(dir + light.wi);\n"
"    \n"
"    float d = d_ggx(h, light.n, light.roughness);\n"
"    float g = g_ggx_smith(light.roughness, light.n, dir, light.wi);\n"
"    float3 f = fresnel(dir, h, light.eta, light.k) * light.power * light.spec_col;\n"
"\n"
"    float nol = clamp(dot(light.n, light.wi), 0.f, 1.f);\n"
"    float nov = clamp(dot(dir, light.n), 0.f, 1.f);\n"
"\n"
"    float3 specular_col = light.roughness < 1.000001f ? f * d * g / clamp(4.0f * (nol * nov + 0.05f), 0.f, 1.f) : (float3)(0.0f);\n"
"\n"
"    return diffuse_col + specular_col;\n"
"}\n"
"\n"
"__kernel void shade(__global const struct PixelElement* pixels, __global const struct LightElement* lights, \n"
"    __global struct OutputElement *output, int num_pixels, float min_dist){\n"
"    int i = get_global_id(0);\n"
"    if(i >= num_pixels){\n"
"        return;\n"
"    }\n"
"\n"
"    float coeff = (lights[i].coeff + 1.0f) / 2.0f;\n"
"\n"
"    float3 diffuse = lambertian(pixels[i].diff_col, pixels[i].p, pixels[i].n, lights[i].p);\n"
"\n"
"    float3 specular = pixels[i].roughness < 1.0001f ? cookTorrance(pixels[i], lights[i]) : (float3)(0.0f);\n"
"\n"
"    float3 bsdf_color = diffuse + specular;\n"
"\n"
"    float3 light_col = getLightCol(lights[i], pixels[i]);\n"
"\n"
"    if(lights[i].type != 0){\n"
"        float3 dir = pixels[i].p - lights[i].p;\n"
"        float dist = fmax(min_dist, length(dir));\n"
"        light_col /= (dist * dist);\n"
"    }\n"
"\n"
"    output[i].col = output[i].col + bsdf_color * light_col * (float3)(coeff);\n"
"}\n";
#endif
